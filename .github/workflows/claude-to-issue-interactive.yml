name: Claude Analysis to Issue (Interactive)

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]

jobs:
  process-claude-analysis:
    if: |
      github.event.issue.pull_request && 
      github.event.comment.user.login == 'claude[bot]' &&
      (contains(github.event.comment.body, 'âŒ') || 
       contains(github.event.comment.body, 'âš ï¸') ||
       contains(github.event.comment.body, 'Issues'))
    
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    
    steps:
      - name: Extract and create interactive prompt
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body;
            const issues = [];
            
            // å•é¡Œã‚’æŠ½å‡º
            const errorMatches = comment.match(/âŒ\s*([^\n]+)/g) || [];
            errorMatches.forEach((match, i) => {
              issues.push({
                id: `error-${i}`,
                type: 'error',
                priority: 'high',
                emoji: 'ğŸ”´',
                content: match.replace(/âŒ\s*/, '').trim()
              });
            });
            
            const warningMatches = comment.match(/âš ï¸\s*([^\n]+)/g) || [];
            warningMatches.forEach((match, i) => {
              issues.push({
                id: `warning-${i}`,
                type: 'warning',
                priority: 'medium',
                emoji: 'ğŸŸ¡',
                content: match.replace(/âš ï¸\s*/, '').trim()
              });
            });
            
            // Architecture Issues ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®æŠ½å‡º
            const archMatch = comment.match(/## Architecture Issues([\s\S]*?)(?=\n## |$)/);
            if (archMatch) {
              const archContent = archMatch[1].trim();
              if (archContent) {
                issues.push({
                  id: 'architecture-1',
                  type: 'architecture',
                  priority: 'high',
                  emoji: 'ğŸ—ï¸',
                  content: 'Architecture Issues detected'
                });
              }
            }
            
            // High Priority Issues ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®æŠ½å‡º
            const highPriorityMatch = comment.match(/## High Priority Issues([\s\S]*?)(?=\n## |$)/);
            if (highPriorityMatch) {
              const highContent = highPriorityMatch[1].trim();
              if (highContent) {
                issues.push({
                  id: 'high-priority-1',
                  type: 'high-priority',
                  priority: 'high',
                  emoji: 'ğŸš¨',
                  content: 'High Priority Issues detected'
                });
              }
            }
            
            if (issues.length === 0) return;
            
            // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªã‚³ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆ
            const interactiveComment = `## ğŸ¤– Claudeæ¤œå‡ºã®å•é¡Œ â†’ Issueä½œæˆ

ä»¥ä¸‹ã®å•é¡ŒãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚**ä½œæˆã—ãŸã„é …ç›®ã«ãƒã‚§ãƒƒã‚¯**ã‚’å…¥ã‚Œã¦ãã ã•ã„ï¼š

${issues.map((issue, i) => 
  `- [ ] ${issue.emoji} **[${issue.priority.toUpperCase()}]** ${issue.content}`
).join('\n')}

### ğŸ“‹ ä½¿ã„æ–¹

1. ä¸Šè¨˜ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã§ä½œæˆã—ãŸã„é …ç›®ã‚’é¸æŠ
2. ã“ã®ã‚³ãƒ¡ãƒ³ãƒˆã«ä»¥ä¸‹ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ï¼š
   - ğŸš€ **é¸æŠã—ãŸé …ç›®ã§issueä½œæˆ**
   - ğŸ“¦ **ã™ã¹ã¦ã‚’1ã¤ã®issueã«ã¾ã¨ã‚ã¦ä½œæˆ**
   - ğŸ·ï¸ **ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ ã—ã¦ä½œæˆ**ï¼ˆãã®å¾Œã‚³ãƒ¡ãƒ³ãƒˆã§ãƒ©ãƒ™ãƒ«æŒ‡å®šï¼‰

### âš™ï¸ ã‚ªãƒ—ã‚·ãƒ§ãƒ³

<details>
<summary>é«˜åº¦ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³</summary>

ã‚³ãƒ¡ãƒ³ãƒˆã§ä»¥ä¸‹ã®å½¢å¼ã§è¿½åŠ æŒ‡å®šã‚‚å¯èƒ½ï¼š
\`\`\`
@claude-issue-bot
labels: bug, high-priority
assignee: @username
milestone: v1.0
project: "Sprint 2024-Q1"
\`\`\`
</details>

---
_Issueä½œæˆID: ${context.payload.comment.id}_`;
            
            const result = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: interactiveComment
            });
            
            // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆå¾Œç¶šå‡¦ç†ç”¨ï¼‰
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `<!-- claude-issue-metadata:${Buffer.from(JSON.stringify({
                commentId: result.data.id,
                issues: issues,
                sourceCommentId: context.payload.comment.id
              })).toString('base64')} -->`
            });

  monitor-and-process-reactions:
    if: |
      github.event_name == 'issue_comment' &&
      github.event.action == 'created' &&
      contains(github.event.comment.body, 'Claudeæ¤œå‡ºã®å•é¡Œ â†’ Issueä½œæˆ')
    
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    
    steps:
      - name: Wait and process reactions
        uses: actions/github-script@v7
        with:
          script: |
            const commentId = context.payload.comment.id;
            const maxAttempts = 10;
            const checkInterval = 30000; // 30ç§’
            
            // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç›£è¦–
            for (let i = 0; i < maxAttempts; i++) {
              await new Promise(resolve => setTimeout(resolve, checkInterval));
              
              const reactions = await github.rest.reactions.listForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId
              });
              
              const rocketReaction = reactions.data.find(r => 
                r.content === 'rocket' && r.user.login !== 'github-actions[bot]'
              );
              
              const packageReaction = reactions.data.find(r => 
                r.content === 'package' && r.user.login !== 'github-actions[bot]'
              );
              
              const labelReaction = reactions.data.find(r => 
                r.content === 'label' && r.user.login !== 'github-actions[bot]'
              );
              
              if (rocketReaction || packageReaction || labelReaction) {
                // ã‚³ãƒ¡ãƒ³ãƒˆã‚’å–å¾—ã—ã¦é¸æŠçŠ¶æ…‹ã‚’è§£æ
                const comment = await github.rest.issues.getComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: commentId
                });
                
                // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’è§£æ
                const lines = comment.data.body.split('\n');
                const selectedItems = [];
                const issuePattern = /- \[([ x])\] (.+)/;
                
                lines.forEach(line => {
                  const match = line.match(issuePattern);
                  if (match && match[1] === 'x') {
                    selectedItems.push({
                      raw: match[2],
                      content: match[2].replace(/^[ğŸ”´ğŸŸ¡ğŸ—ï¸ğŸš¨]\s*\*\*\[.+?\]\*\*\s*/, '').trim()
                    });
                  }
                });
                
                // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ¤œç´¢
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number
                });
                
                const metadataComment = comments.data.find(c => 
                  c.body.includes('<!-- claude-issue-metadata:')
                );
                
                let metadata = null;
                if (metadataComment) {
                  const metadataMatch = metadataComment.body.match(/<!-- claude-issue-metadata:(.+?) -->/);
                  if (metadataMatch) {
                    metadata = JSON.parse(Buffer.from(metadataMatch[1], 'base64').toString());
                  }
                }
                
                // Issueä½œæˆå‡¦ç†
                const createdIssues = [];
                
                if (rocketReaction && selectedItems.length > 0) {
                  // å€‹åˆ¥ã«issueä½œæˆ
                  for (const item of selectedItems) {
                    const issueTitle = item.content.length > 60 
                      ? `${item.content.substring(0, 60)}...`
                      : item.content;
                    
                    const issueBody = `## æ¦‚è¦
${item.content}

## ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
- æ¤œå‡ºå…ƒ: PR #${context.issue.number} - https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${context.issue.number}
- æ¤œå‡ºè€…: Claude Code Action
- æ¤œå‡ºæ—¥æ™‚: ${new Date().toISOString()}
- å…ƒã‚³ãƒ¡ãƒ³ãƒˆ: ${comment.data.html_url}

## å¯¾å¿œæ–¹é‡
TODO: å¯¾å¿œæ–¹é‡ã‚’è¨˜è¼‰

---
_ã“ã®issueã¯Claude Code Actionã®åˆ†æçµæœã‹ã‚‰è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸ_`;
                    
                    try {
                      const created = await github.rest.issues.create({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        title: `[Claude] ${issueTitle}`,
                        body: issueBody,
                        labels: ['claude-detected', 'auto-generated']
                      });
                      
                      createdIssues.push(created.data);
                    } catch (error) {
                      console.error('Failed to create issue:', error);
                    }
                  }
                  
                } else if (packageReaction) {
                  // ã™ã¹ã¦ã‚’1ã¤ã®issueã«ã¾ã¨ã‚ã‚‹
                  const allItems = selectedItems.length > 0 ? selectedItems : 
                    lines.filter(line => line.match(/- \[ \] (.+)/))
                          .map(line => ({ content: line.match(/- \[ \] (.+)/)[1] }));
                  
                  if (allItems.length > 0) {
                    const bundledTitle = `[Claude] ${allItems.length}ä»¶ã®å•é¡Œæ¤œå‡º (PR #${context.issue.number})`;
                    const bundledBody = `## æ¤œå‡ºã•ã‚ŒãŸå•é¡Œ

${allItems.map((item, i) => `### ${i + 1}. ${item.content}

---`).join('\n\n')}

## ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
- PR: #${context.issue.number} - https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${context.issue.number}
- æ¤œå‡ºæ—¥æ™‚: ${new Date().toISOString()}
- æ¤œå‡ºè€…: Claude Code Action

## å¯¾å¿œæ–¹é‡
TODO: å„é …ç›®ã«å¯¾ã™ã‚‹å¯¾å¿œæ–¹é‡ã‚’è¨˜è¼‰

---
_ã“ã®issueã¯Claude Code Actionã®åˆ†æçµæœã‹ã‚‰è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸ_`;
                    
                    try {
                      const created = await github.rest.issues.create({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        title: bundledTitle,
                        body: bundledBody,
                        labels: ['claude-detected', 'bundled', 'auto-generated']
                      });
                      
                      createdIssues.push(created.data);
                    } catch (error) {
                      console.error('Failed to create bundled issue:', error);
                    }
                  }
                }
                
                // çµæœã‚’ã‚³ãƒ¡ãƒ³ãƒˆ
                if (createdIssues.length > 0) {
                  const resultComment = `âœ… **Issueä½œæˆå®Œäº†ï¼**

${createdIssues.map(issue => `- [#${issue.number}](${issue.html_url}): ${issue.title}`).join('\n')}

_${createdIssues.length}ä»¶ã®issueãŒä½œæˆã•ã‚Œã¾ã—ãŸ_`;
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: resultComment
                  });
                } else {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: 'âŒ Issueä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚'
                  });
                }
                
                break; // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†å®Œäº†
              }
            }

  # ç›´æ¥ã‚³ãƒãƒ³ãƒ‰å‡¦ç†ï¼ˆå¾“æ¥ã®/create-issueã‚³ãƒãƒ³ãƒ‰å¯¾å¿œï¼‰
  create-issues-from-command:
    if: |
      github.event.issue.pull_request && 
      (startsWith(github.event.comment.body, '/create-issues') ||
       startsWith(github.event.comment.body, '/create-issue'))
    
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: read
      contents: read
    
    steps:
      - name: Parse command and create issues
        uses: actions/github-script@v7
        with:
          script: |
            const command = context.payload.comment.body;
            
            // ã‚³ãƒãƒ³ãƒ‰ãƒ‘ãƒ¼ã‚¹
            const createMatch = command.match(/\/create-issues?\s*(.*)/);
            if (!createMatch) return;
            
            const args = createMatch[1] || '';
            const lines = args.split('\n');
            const title = lines[0] || `Issue from PR #${context.issue.number}`;
            const body = lines.slice(1).join('\n') || 'Issue created from PR comment';
            
            // ã‚ªãƒ—ã‚·ãƒ§ãƒ³è§£æ
            const labelMatch = command.match(/--label[s]?="?([^"\s]+)"?/);
            const assignMatch = command.match(/--assign="?([^"\s]+)"?/);
            
            const extraLabels = labelMatch ? labelMatch[1].split(',') : [];
            const assignee = assignMatch ? assignMatch[1].replace('@', '') : null;
            
            // Issueä½œæˆ
            try {
              const labels = ['claude-detected', 'manual'].concat(extraLabels);
              
              const issueData = {
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: `## æ¦‚è¦
${body}

## ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
- ä½œæˆå…ƒ: PR #${context.issue.number} - https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${context.issue.number}
- ä½œæˆè€…: @${context.payload.comment.user.login}
- ä½œæˆæ—¥æ™‚: ${new Date().toISOString()}

---
_ã“ã®issueã¯æ‰‹å‹•ã‚³ãƒãƒ³ãƒ‰ã‹ã‚‰ä½œæˆã•ã‚Œã¾ã—ãŸ_`,
                labels: labels.filter(Boolean)
              };
              
              if (assignee) issueData.assignees = [assignee];
              
              const created = await github.rest.issues.create(issueData);
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `âœ… Issueä½œæˆå®Œäº†: [#${created.data.number}](${created.data.html_url}) - ${created.data.title}`
              });
              
            } catch (error) {
              console.error('Failed to create issue:', error);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: 'âŒ Issueä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚'
              });
            }