#!/usr/bin/env python3
"""
Ramsey Experiment Class - RamseyÊåØÂãïÂÆüÈ®ìÂ∞ÇÁî®„ÇØ„É©„Çπ
BaseExperiment„ÇíÁ∂ôÊâø„Åó„ÄÅRamseyÂÆüÈ®ì„Å´ÁâπÂåñ„Åó„ÅüÂÆüË£Ö„ÇíÊèê‰æõ
"""

import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Any, Dict, List, Optional

import numpy as np

from ...core.base_experiment import BaseExperiment


class RamseyExperiment(BaseExperiment):
    """
    RamseyÊåØÂãïÂÆüÈ®ì„ÇØ„É©„Çπ

    ÁâπÂåñÊ©üËÉΩ:
    - RamseyÂõûË∑Ø„ÅÆËá™ÂãïÁîüÊàê
    - ÊåØÂãï„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞
    - ÈÅÖÂª∂ÊôÇÈñì„Çπ„Ç≠„É£„É≥ÂÆüÈ®ì
    - T2*ÊôÇÂÆöÊï∞Êé®ÂÆö
    """

    def __init__(self, experiment_name: str = None, enable_fitting: bool = True, **kwargs):
        # RamseyÂÆüÈ®ìÂõ∫Êúâ„ÅÆ„Éë„É©„É°„Éº„Çø„ÇíÊäΩÂá∫ÔºàBaseExperiment„Å´„ÅØÊ∏°„Åï„Å™„ÅÑÔºâ
        ramsey_specific_params = {
            'delay_points', 'max_delay', 'detuning', 'delay_times', 'enable_fitting'
        }
        
        # BaseExperiment„Å´Ê∏°„Åôkwargs„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
        base_kwargs = {k: v for k, v in kwargs.items() if k not in ramsey_specific_params}
        
        super().__init__(experiment_name, **base_kwargs)

        # RamseyÂÆüÈ®ìÂõ∫Êúâ„ÅÆË®≠ÂÆö
        self.expected_t2_star = 1000  # ÂàùÊúüÊé®ÂÆöÂÄ§ [ns] - „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„ÅÆÂàùÊúüÂÄ§„ÅÆ„Åø„Å´‰ΩøÁî®
        self.expected_detuning = 0.0  # ÊúüÂæÖ„Éá„ÉÅ„É•„Éº„Éã„É≥„Ç∞ [MHz]
        self.enable_fitting = enable_fitting  # „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ÊúâÂäπÂåñ„Éï„É©„Ç∞
        
        # RamseyÂÆüÈ®ì„Åß„ÅØreadout mitigation„ÇíÊúâÂäπÂåñ
        self.mitigation_options = {
            "ro_error_mitigation": "pseudo_inverse"
        }
        self.mitigation_info = self.mitigation_options

        if enable_fitting:
            print(f"Ramsey experiment: Standard Ramsey measurement with fitting enabled")
        else:
            print(f"Ramsey experiment: Standard Ramsey measurement (fitting disabled)")

    def create_circuits(self, **kwargs) -> List[Any]:
        """
        RamseyÂÆüÈ®ìÂõûË∑Ø‰ΩúÊàê

        Args:
            delay_points: ÈÅÖÂª∂ÊôÇÈñìÁÇπÊï∞ (default: 51)
            max_delay: ÊúÄÂ§ßÈÅÖÂª∂ÊôÇÈñì [ns] (default: 50000)
            detuning: Âë®Ê≥¢Êï∞„Éá„ÉÅ„É•„Éº„Éã„É≥„Ç∞ [MHz] (default: 0.0)
            delay_times: Áõ¥Êé•ÊåáÂÆö„Åô„ÇãÈÅÖÂª∂ÊôÇÈñì„É™„Çπ„Éà [ns] (optional)

        Returns:
            RamseyÂõûË∑Ø„É™„Çπ„Éà
        """
        delay_points = kwargs.get("delay_points", 51)
        max_delay = kwargs.get("max_delay", 200000)
        detuning = kwargs.get("detuning", 0.0)

        # ÈÅÖÂª∂ÊôÇÈñìÁØÑÂõ≤
        if "delay_times" in kwargs:
            delay_times = np.array(kwargs["delay_times"])
        else:
            # „Éá„Éï„Ç©„É´„Éà: 50ns„Äú200Œºs„ÅÆÂØæÊï∞„Çπ„Ç±„Éº„É´„Åß51ÁÇπ
            delay_times = np.logspace(np.log10(50), np.log10(200 * 1000), num=51)
            if delay_points != 51:
                delay_times = np.linspace(50, max_delay, delay_points)

        # „É°„Çø„Éá„Éº„Çø‰øùÂ≠ò
        self.experiment_params = {
            "delay_times": delay_times.tolist(),
            "delay_points": len(delay_times),
            "max_delay": max_delay,
            "detuning": detuning,
        }

        # RamseyÂõûË∑Ø‰ΩúÊàê
        circuits = []
        for delay_time in delay_times:
            circuit = self._create_single_ramsey_circuit(delay_time, detuning)
            circuits.append(circuit)

        print(
            f"Ramsey circuits: Delay range {len(delay_times)} points from {delay_times[0]:.1f} to {delay_times[-1]:.1f} ns, detuning={detuning} MHz"
        )

        return circuits
        
    def run_ramsey_experiment_parallel(self, devices: List[str] = ['qulacs'], shots: int = 1024,
                                      parallel_workers: int = 4, **kwargs) -> Dict[str, Any]:
        """
        RamseyÂÆüÈ®ì„ÅÆ‰∏¶ÂàóÂÆüË°åÔºàdelay time„ÅÆÈ†ÜÂ∫è„Çí‰øùÊåÅÔºâ
        """
        print(f"üî¨ Running Ramsey experiment with {parallel_workers} parallel workers")
        
        # ÂõûË∑Ø‰ΩúÊàê
        circuits = self.create_circuits(**kwargs)
        delay_times = self.experiment_params['delay_times']
        
        print(f"   üìä {len(circuits)} circuits √ó {len(devices)} devices = {len(circuits) * len(devices)} jobs")
        
        # ‰∏¶ÂàóÂÆüË°åÔºàÈ†ÜÂ∫è‰øùÊåÅÔºâ
        job_data = self._submit_ramsey_circuits_parallel_with_order(
            circuits, devices, shots, parallel_workers
        )
        
        # ÁµêÊûúÂèéÈõÜÔºàÈ†ÜÂ∫è‰øùÊåÅÔºâ
        raw_results = self._collect_ramsey_results_parallel_with_order(
            job_data, parallel_workers
        )
        
        # ÁµêÊûúËß£ÊûêÔºà„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞‰ªò„ÅçÔºâ
        try:
            analysis = self.analyze_results(raw_results)
        except Exception as e:
            print(f"Analysis failed: {e}, creating minimal analysis")
            analysis = {
                'experiment_info': {
                    'delay_points': len(delay_times),
                    'error': str(e)
                },
                'device_results': {}
            }
        
        return {
            'delay_times': delay_times,
            'device_results': analysis['device_results'],
            'analysis': analysis,
            'method': 'ramsey_parallel_quantumlib'
        }
        
    def _submit_ramsey_circuits_parallel_with_order(self, circuits: List[Any], devices: List[str],
                                                   shots: int, parallel_workers: int) -> Dict[str, List[Dict]]:
        """
        RamseyÂõûË∑Ø„ÅÆ‰∏¶ÂàóÊäïÂÖ•ÔºàCHSH„Çπ„Çø„Ç§„É´„ÅßÈ†ÜÂ∫è‰øùÊåÅÔºâ
        """
        print(f"Enhanced Ramsey parallel submission: {parallel_workers} workers")
        
        if not self.oqtopus_available:
            return self._submit_ramsey_circuits_locally_parallel(circuits, devices, shots, parallel_workers)
        
        # È†ÜÂ∫è‰øùÊåÅ„ÅÆ„Åü„ÇÅ„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†
        all_job_data = {device: [None] * len(circuits) for device in devices}
        
        # ÂõûË∑Ø„Å®„Éá„Éê„Ç§„Çπ„ÅÆ„Éö„Ç¢‰ΩúÊàêÔºàdelay_timeÈ†ÜÂ∫è„Çí‰øùÊåÅÔºâ
        circuit_device_pairs = []
        for circuit_idx, circuit in enumerate(circuits):
            for device in devices:
                circuit_device_pairs.append((circuit_idx, circuit, device))
        
        def submit_single_ramsey_circuit(args):
            circuit_idx, circuit, device = args
            try:
                job_id = self.submit_circuit_to_oqtopus(circuit, shots, device)
                if job_id:
                    return device, job_id, circuit_idx, True
                else:
                    return device, None, circuit_idx, False
            except Exception as e:
                delay_time = self.experiment_params['delay_times'][circuit_idx]
                print(f"Ramsey Circuit {circuit_idx} (œÑ={delay_time:.0f}ns) ‚Üí {device}: {e}")
                return device, None, circuit_idx, False
        
        # ‰∏¶ÂàóÊäïÂÖ•ÂÆüË°å
        with ThreadPoolExecutor(max_workers=parallel_workers) as executor:
            futures = [executor.submit(submit_single_ramsey_circuit, args) for args in circuit_device_pairs]
            
            for future in as_completed(futures):
                device, job_id, circuit_idx, success = future.result()
                if success and job_id:
                    all_job_data[device][circuit_idx] = {
                        'job_id': job_id,
                        'circuit_index': circuit_idx,
                        'delay_time': self.experiment_params['delay_times'][circuit_idx],
                        'submitted': True
                    }
                    delay_time = self.experiment_params['delay_times'][circuit_idx]
                    print(f"Ramsey Circuit {circuit_idx+1} (œÑ={delay_time:.0f}ns) ‚Üí {device}: {job_id[:8]}...")
                else:
                    all_job_data[device][circuit_idx] = {
                        'job_id': None,
                        'circuit_index': circuit_idx,
                        'delay_time': self.experiment_params['delay_times'][circuit_idx],
                        'submitted': False
                    }
        
        for device in devices:
            successful_jobs = sum(1 for job_data in all_job_data[device] if job_data and job_data['submitted'])
            print(f"‚úÖ {device}: {successful_jobs} Ramsey jobs submitted (order preserved)")
        
        return all_job_data
        
    def _submit_ramsey_circuits_locally_parallel(self, circuits: List[Any], devices: List[str],
                                                shots: int, parallel_workers: int) -> Dict[str, List[Dict]]:
        """RamseyÂõûË∑Ø„Çí„É≠„Éº„Ç´„É´„Ç∑„Éü„É•„É¨„Éº„Çø„Éº„Åß‰∏¶ÂàóÂÆüË°å"""
        print(f"Ramsey Local parallel execution: {parallel_workers} workers")
        
        all_job_data = {device: [None] * len(circuits) for device in devices}
        
        circuit_device_pairs = []
        for circuit_idx, circuit in enumerate(circuits):
            for device in devices:
                circuit_device_pairs.append((circuit_idx, circuit, device))
        
        def run_single_ramsey_circuit_locally(args):
            circuit_idx, circuit, device = args
            try:
                result = self.run_circuit_locally(circuit, shots)
                if result:
                    job_id = result['job_id']
                    if not hasattr(self, '_local_results'):
                        self._local_results = {}
                    self._local_results[job_id] = result
                    return device, job_id, circuit_idx, True
                else:
                    return device, None, circuit_idx, False
            except Exception as e:
                delay_time = self.experiment_params['delay_times'][circuit_idx]
                print(f"Local Ramsey circuit {circuit_idx} (œÑ={delay_time:.0f}ns) ‚Üí {device}: {e}")
                return device, None, circuit_idx, False
        
        with ThreadPoolExecutor(max_workers=parallel_workers) as executor:
            futures = [executor.submit(run_single_ramsey_circuit_locally, args) for args in circuit_device_pairs]
            
            for future in as_completed(futures):
                device, job_id, circuit_idx, success = future.result()
                if success and job_id:
                    all_job_data[device][circuit_idx] = {
                        'job_id': job_id,
                        'circuit_index': circuit_idx,
                        'delay_time': self.experiment_params['delay_times'][circuit_idx],
                        'submitted': True
                    }
                else:
                    all_job_data[device][circuit_idx] = {
                        'job_id': None,
                        'circuit_index': circuit_idx,
                        'delay_time': self.experiment_params['delay_times'][circuit_idx],
                        'submitted': False
                    }
        
        for device in devices:
            successful = sum(1 for job in all_job_data[device] if job and job['submitted'])
            print(f"‚úÖ {device}: {successful} Ramsey circuits completed locally (order preserved)")
        
        return all_job_data
            
    def _collect_ramsey_results_parallel_with_order(self, job_data: Dict[str, List[Dict]],
                                                   parallel_workers: int) -> Dict[str, List[Dict]]:
        """RamseyÁµêÊûú„ÅÆ‰∏¶ÂàóÂèéÈõÜÔºàCHSH„Çπ„Çø„Ç§„É´„ÅßÈ†ÜÂ∫è‰øùÊåÅÔºâ"""
        
        # Á∑è„Ç∏„Éß„ÉñÊï∞„ÇíË®àÁÆó„Åó„Å¶ÂèéÈõÜÈñãÂßã„Çí„É≠„Ç∞
        total_jobs_to_collect = sum(1 for device_jobs in job_data.values() 
                                   for job in device_jobs if job and job.get('submitted', False))
        print(f"üìä Starting Ramsey results collection: {total_jobs_to_collect} jobs from {len(job_data)} devices")
        
        # Handle local results
        if hasattr(self, '_local_results'):
            print("Using cached local Ramsey simulation results...")
            all_results = {}
            for device, device_job_data in job_data.items():
                device_results = []
                for job_info in device_job_data:
                    if job_info and job_info['submitted'] and job_info['job_id'] in self._local_results:
                        result = self._local_results[job_info['job_id']]
                        device_results.append(result)
                    else:
                        device_results.append(None)
                all_results[device] = device_results
                successful = sum(1 for r in device_results if r is not None)
                print(f"‚úÖ {device}: {successful} Ramsey local results collected")
            return all_results
        
        if not self.oqtopus_available:
            print("OQTOPUS not available for Ramsey collection")
            return {device: [None] * len(device_job_data) for device, device_job_data in job_data.items()}
        
        all_results = {device: [None] * len(device_job_data) for device, device_job_data in job_data.items()}
        
        job_collection_tasks = []
        for device, device_job_data in job_data.items():
            for circuit_idx, job_info in enumerate(device_job_data):
                if job_info and job_info['submitted'] and job_info['job_id']:
                    job_collection_tasks.append((job_info['job_id'], device, circuit_idx))
        
        def collect_single_ramsey_result(args):
            job_id, device, circuit_idx = args
            try:
                # „Ç∏„Éß„ÉñÂÆå‰∫Ü„Åæ„Åß„Éù„Éº„É™„É≥„Ç∞
                result = self._poll_job_until_completion(job_id, timeout_minutes=5)
                # OQTOPUS„Ç∏„Éß„ÉñÊßãÈÄ†„Å´Âü∫„Å•„ÅèÊàêÂäüÂà§ÂÆö: status == 'succeeded'
                if result and result.get('status') == 'succeeded':
                    # Ë§áÊï∞„ÅÆÊñπÊ≥ï„ÅßÊ∏¨ÂÆöÁµêÊûú„ÇíÂèñÂæó„ÇíË©¶Ë°å
                    counts = None
                    shots = 0
                    
                    # ÊñπÊ≥ï1: BaseExperiment„ÅÆget_oqtopus_result„ÅåÁõ¥Êé•counts„ÇíËøî„ÅôÂ†¥Âêà
                    if 'counts' in result:
                        counts = result['counts']
                        shots = result.get('shots', 0)
                    
                    # ÊñπÊ≥ï2: job_infoÂÜÖ„ÅÆresultÊßãÈÄ†„Åã„ÇâÂèñÂæó
                    if not counts:
                        job_info = result.get('job_info', {})
                        if isinstance(job_info, dict):
                            # OQTOPUS resultÊßãÈÄ†„ÇíÊé¢Á¥¢
                            sampling_result = job_info.get('result', {}).get('sampling', {})
                            if sampling_result:
                                counts = sampling_result.get('counts', {})
                    
                    # ÊñπÊ≥ï3: job_infoËá™‰Ωì„ÅåresultÂΩ¢Âºè„ÅÆÂ†¥Âêà
                    if not counts and 'job_info' in result:
                        job_info = result['job_info']
                        if isinstance(job_info, dict) and 'job_info' in job_info:
                            inner_job_info = job_info['job_info']
                            if isinstance(inner_job_info, dict):
                                result_data = inner_job_info.get('result', {})
                                if 'sampling' in result_data:
                                    counts = result_data['sampling'].get('counts', {})
                                elif 'counts' in result_data:
                                    counts = result_data['counts']

                    if counts:
                        # ÊàêÂäü„Éá„Éº„Çø„ÇíÊ®ôÊ∫ñÂΩ¢Âºè„Å´Â§âÊèõ
                        processed_result = {
                            'success': True,
                            'counts': dict(counts),  # Counter„ÇíËæûÊõ∏„Å´Â§âÊèõ
                            'status': result.get('status'),
                            'execution_time': result.get('execution_time', 0),
                            'shots': shots or sum(counts.values()) if counts else 0
                        }
                        return device, processed_result, job_id, circuit_idx, True
                    else:
                        delay_time = self.experiment_params['delay_times'][circuit_idx]
                        print(f"‚ö†Ô∏è {device}[{circuit_idx}] (œÑ={delay_time:.0f}ns): {job_id[:8]}... no measurement data")
                        return device, None, job_id, circuit_idx, False
                else:
                    # „Ç∏„Éß„ÉñÂ§±Êïó„ÅÆÂ†¥Âêà
                    delay_time = self.experiment_params['delay_times'][circuit_idx]
                    status = result.get('status', 'unknown') if result else 'no_result'
                    # „Çà„ÇäË©≥Á¥∞„Å™Â§±ÊïóÊÉÖÂ†±„ÇíË°®Á§∫
                    message = ""
                    if result:
                        job_info = result.get('job_info', {})
                        message = job_info.get('message', '')
                        if message:
                            message = f" - {message}"
                    print(f"‚ö†Ô∏è {device}[{circuit_idx}] (œÑ={delay_time:.0f}ns): {job_id[:8]}... {status}{message}")
                    return device, None, job_id, circuit_idx, False
            except Exception as e:
                delay_time = self.experiment_params['delay_times'][circuit_idx]
                print(f"‚ùå {device}[{circuit_idx}] (œÑ={delay_time:.0f}ns): {job_id[:8]}... error: {str(e)[:50]}")
                return device, None, job_id, circuit_idx, False
        
        with ThreadPoolExecutor(max_workers=parallel_workers) as executor:
            futures = [executor.submit(collect_single_ramsey_result, args) for args in job_collection_tasks]
            
            completed_jobs = 0
            successful_jobs = 0
            total_jobs = len(futures)
            last_progress_percent = 0
            
            for future in as_completed(futures):
                device, result, job_id, circuit_idx, success = future.result()
                completed_jobs += 1
                
                if success and result:
                    successful_jobs += 1
                    all_results[device][circuit_idx] = result
                    delay_time = self.experiment_params['delay_times'][circuit_idx]
                    print(f"‚úÖ {device}[{circuit_idx}] (œÑ={delay_time:.0f}ns): {job_id[:8]}... collected ({completed_jobs}/{total_jobs})")
                else:
                    # Â§±Êïó„Ç±„Éº„Çπ„ÅØÊó¢„Å´ÂÄãÂà•„É°„ÇΩ„ÉÉ„ÉâÂÜÖ„Åß„É≠„Ç∞Âá∫ÂäõÊ∏à„Åø
                    pass
                
                # ÈÄ≤Êçó„Çµ„Éû„É™„Éº„Çí20%„Åî„Å®„Å´Ë°®Á§∫
                progress_percent = (completed_jobs * 100) // total_jobs
                if progress_percent >= last_progress_percent + 20 and progress_percent < 100:
                    print(f"üìà Ramsey Collection Progress: {completed_jobs}/{total_jobs} ({progress_percent}%) - {successful_jobs} successful")
                    last_progress_percent = progress_percent
        
        # ÊúÄÁµÇÁµêÊûú„Çµ„Éû„É™„Éº
        total_successful = sum(1 for device_results in all_results.values() 
                              for r in device_results if r is not None)
        total_attempted = sum(1 for device_jobs in job_data.values() 
                             for job in device_jobs if job and job.get('submitted', False))
        success_rate = (total_successful / total_attempted * 100) if total_attempted > 0 else 0
        
        print(f"üéâ Ramsey Collection Complete: {total_successful}/{total_attempted} successful ({success_rate:.1f}%)")
        
        # ÁµêÊûúÁµ±Ë®à„ÅÆË°®Á§∫„Å®Â§±Êïó„Ç∏„Éß„Éñ„ÅÆÂ†±Âëä
        for device in job_data.keys():
            successful = sum(1 for r in all_results[device] if r is not None)
            total = len(job_data[device])
            failed = total - successful
            
            if failed > 0:
                device_success_rate = (successful / total * 100) if total > 0 else 0
                print(f"‚úÖ {device}: {successful}/{total} Ramsey results collected (success rate: {device_success_rate:.1f}%)")
                print(f"   ‚ö†Ô∏è {failed} jobs failed - analysis will continue with available data")
            else:
                print(f"‚úÖ {device}: {successful}/{total} Ramsey results collected (100% success)")
        
        return all_results
        
    def _poll_job_until_completion(self, job_id: str, timeout_minutes: int = 5, poll_interval: float = 2.0):
        """
        „Ç∏„Éß„Éñ„ÅåÂÆå‰∫Ü„Åô„Çã„Åæ„Åß„Éù„Éº„É™„É≥„Ç∞
        
        Args:
            job_id: „Ç∏„Éß„ÉñID
            timeout_minutes: „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÊôÇÈñìÔºàÂàÜÔºâ
            poll_interval: „Éù„Éº„É™„É≥„Ç∞ÈñìÈöîÔºàÁßíÔºâ
            
        Returns:
            ÂÆå‰∫Ü„Åó„Åü„Ç∏„Éß„Éñ„ÅÆÁµêÊûú„ÄÅ„Åæ„Åü„ÅØNone
        """
        import time
        
        timeout_seconds = timeout_minutes * 60
        start_time = time.time()
        last_status = None
        
        while time.time() - start_time < timeout_seconds:
            try:
                result = self.get_oqtopus_result(job_id, timeout_minutes=1, verbose_log=False)  # Áü≠„ÅÑ„Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÅßÂèñÂæó
                
                if not result:
                    time.sleep(poll_interval)
                    continue
                    
                status = result.get('status', 'unknown')
                
                # Áä∂ÊÖã„ÅåÂ§â„Çè„Å£„ÅüÂ†¥Âêà„ÅÆ„Åø„É≠„Ç∞Âá∫ÂäõÔºàÈÄ≤ÊçóÁä∂ÊÖã„ÅÆ„ÅøÔºâ
                if status != last_status:
                    if status in ['running', 'submitted', 'pending']:
                        print(f"‚è≥ {job_id[:8]}... {status}")
                    elif status in ['succeeded', 'failed', 'cancelled']:
                        print(f"üèÅ {job_id[:8]}... {status}")
                    last_status = status
                
                # ÁµÇ‰∫ÜÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                if status in ['succeeded', 'failed', 'cancelled']:
                    return result
                elif status in ['running', 'submitted', 'pending']:
                    # „Åæ„Å†ÂÆüË°å‰∏≠ - Á∂öË°å
                    time.sleep(poll_interval)
                    continue
                else:
                    # ‰∏çÊòé„Å™Áä∂ÊÖã - Â∞ë„ÅóÂæÖ„Å£„Å¶„É™„Éà„É©„Ç§
                    time.sleep(poll_interval)
                    continue
                    
            except Exception as e:
                # ‰∏ÄÊôÇÁöÑ„Å™„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØ„É™„Éà„É©„Ç§
                time.sleep(poll_interval)
                continue
        
        # „Çø„Ç§„É†„Ç¢„Ç¶„Éà
        print(f"‚è∞ Job {job_id[:8]}... timed out after {timeout_minutes} minutes")
        return None

    def run_experiment(self, devices: List[str] = ['qulacs'], shots: int = 1024,
                      parallel_workers: int = 4, **kwargs) -> Dict[str, Any]:
        """
        RamseyÂÆüÈ®ìÂÆüË°åÔºàbase_cli„ÅÆÁµ±‰∏Ä„Éï„É≠„Éº„Å´Âæì„ÅÜÔºâ
        """
        # base_cli„ÅåÁõ¥Êé•‰∏¶Âàó„É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„Åô„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØÂü∫Êú¨ÁöÑ„Å™ÁµêÊûúÂèéÈõÜ„ÅÆ„Åø
        print("‚ö†Ô∏è run_experiment called directly - use CLI framework instead")
        return self.run_ramsey_experiment_parallel(
            devices=devices, shots=shots, parallel_workers=parallel_workers, **kwargs
        )

    def _create_single_ramsey_circuit(self, delay_time: float, detuning: float = 0.0):
        """
        Âçò‰∏ÄRamseyÂõûË∑Ø‰ΩúÊàê
        """
        try:
            from qiskit import ClassicalRegister, QuantumCircuit, QuantumRegister
        except ImportError:
            raise ImportError("Qiskit is required for circuit creation")

        # 1ÈáèÂ≠ê„Éì„ÉÉ„Éà + 1Âè§ÂÖ∏„Éì„ÉÉ„Éà
        qubits = QuantumRegister(1, 'q')
        bits = ClassicalRegister(1, 'c')
        qc = QuantumCircuit(qubits, bits)

        # First œÄ/2 pulse
        qc.ry(np.pi/2, 0)

        # ÈÅÖÂª∂ÊôÇÈñì„ÅÆÈñìÂæÖÊ©üÔºàËá™Áî±ÈÄ≤ÂåñÔºâ
        qc.delay(int(delay_time), 0, unit="ns")

        # „Éá„ÉÅ„É•„Éº„Éã„É≥„Ç∞„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ‰ΩçÁõ∏ÂõûËª¢„ÇíËøΩÂä†
        if detuning != 0.0:
            # ‰ΩçÁõ∏ = 2œÄ √ó detuning [MHz] √ó delay_time [ns] √ó 1e-3
            phase = 2 * np.pi * detuning * delay_time * 1e-3
            qc.rz(phase, 0)

        # Second œÄ/2 pulse (analysis pulse)
        qc.ry(np.pi/2, 0)

        # ZÂü∫Â∫ïÊ∏¨ÂÆö
        qc.measure(0, 0)

        return qc

    def analyze_results(self, results: Dict[str, List[Dict[str, Any]]], **kwargs) -> Dict[str, Any]:
        """
        RamseyÂÆüÈ®ìÁµêÊûúËß£Êûê
        """
        if not results:
            return {'error': 'No results to analyze'}

        delay_times = np.array(self.experiment_params["delay_times"])

        analysis = {
            "experiment_info": {
                "delay_points": len(delay_times),
                "expected_t2_star": self.expected_t2_star,
                "detuning": self.experiment_params.get("detuning", 0.0),
            },
            "device_results": {},
        }

        for device, device_results in results.items():
            if not device_results:
                continue

            device_analysis = self._analyze_device_results(device_results, delay_times)
            analysis["device_results"][device] = device_analysis

            # „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„ÅåÊúâÂäπ„Å™Â†¥Âêà„ÅÆ„ÅøÂÆüË°å
            if self.enable_fitting:
                try:
                    t2_star_fitted, detuning_fitted, fitting_quality = self._estimate_ramsey_params_with_quality(
                        device_analysis["p1_values"], delay_times
                    )
                    quality_str = f"({fitting_quality['method']}, R¬≤={fitting_quality['r_squared']:.3f})"
                    print(f"{device}: T2* = {t2_star_fitted:.1f} ns, detuning = {detuning_fitted:.3f} MHz {quality_str} [with RO mitigation]")
                except Exception as e:
                    print(f"Fitting error for {device}: {e}, using default values")
                    t2_star_fitted, detuning_fitted, fitting_quality = (
                        float(self.expected_t2_star), 0.0, {
                            'method': 'error_fallback', 'r_squared': 0.0, 'error': 'exception'
                        }
                    )
            else:
                # „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„Å™„ÅóÔºöÁµ±Ë®àÊÉÖÂ†±„ÅÆ„ÅøË°®Á§∫
                t2_star_fitted, detuning_fitted, fitting_quality = (
                    0.0, 0.0, {
                        'method': 'no_fitting', 'r_squared': 0.0, 'error': 'disabled'
                    }
                )
                stats = device_analysis["statistics"]
                oscillation_amp = stats.get("oscillation_amplitude", 0.0)
                print(f"{device}: Raw data oscillation amplitude = {oscillation_amp:.3f} [with RO mitigation]")
            
            analysis["device_results"][device]["t2_star_fitted"] = t2_star_fitted
            analysis["device_results"][device]["detuning_fitted"] = detuning_fitted
            analysis["device_results"][device]["fitting_quality"] = fitting_quality

        return analysis

    def _analyze_device_results(self, device_results: List[Dict[str, Any]], 
                              delay_times: np.ndarray) -> Dict[str, Any]:
        """
        Âçò‰∏Ä„Éá„Éê„Ç§„ÇπÁµêÊûúËß£Êûê
        """
        p1_values = []

        for i, result in enumerate(device_results):
            if result and result.get("success", False):
                counts = result.get("counts", {})
                if counts:  # „Ç´„Ç¶„É≥„Éà„Éá„Éº„Çø„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅÆ„Åø
                    # P(1)Á¢∫ÁéáË®àÁÆóÔºàreadout mitigation„ÅßË£úÊ≠£Ê∏à„ÅøÔºâ
                    p1 = self._calculate_p1_probability(counts)
                    p1_values.append(p1)
                else:
                    p1_values.append(np.nan)
            else:
                # Â§±Êïó„Åó„Åü„Ç∏„Éß„Éñ„ÇÑÁÑ°Âäπ„Å™ÁµêÊûú„ÅØNaN„Å®„Åó„Å¶Ë®òÈå≤
                p1_values.append(np.nan)

        # Áµ±Ë®àË®àÁÆó
        valid_p1s = np.array([p for p in p1_values if not np.isnan(p)])

        # ÊúâÂäπ„Éá„Éº„Çø„Åß„ÅÆÁµ±Ë®àË®àÁÆó
        total_jobs = len(p1_values)
        successful_jobs = len(valid_p1s)
        failed_jobs = total_jobs - successful_jobs
        
        return {
            "p1_values": p1_values,
            "delay_times": delay_times.tolist(),
            "statistics": {
                "initial_p1": (
                    float(valid_p1s[0])
                    if len(valid_p1s) > 0
                    else 0.5
                ),
                "final_p1": (
                    float(valid_p1s[-1])
                    if len(valid_p1s) > 0
                    else 0.5
                ),
                "success_rate": successful_jobs / total_jobs if total_jobs > 0 else 0,
                "successful_jobs": successful_jobs,
                "failed_jobs": failed_jobs,
                "total_jobs": total_jobs,
                "oscillation_amplitude": (
                    float(max(valid_p1s) - min(valid_p1s))
                    if len(valid_p1s) > 1
                    else 0.0
                ),
            },
        }

    def _calculate_p1_probability(self, counts: Dict[str, int]) -> float:
        """
        P(1)Á¢∫ÁéáË®àÁÆóÔºàOQTOPUS 10ÈÄ≤Êï∞countsÂØæÂøúÔºâ
        """
        # OQTOPUS„ÅÆ10ÈÄ≤Êï∞counts„Çí2ÈÄ≤Êï∞ÂΩ¢Âºè„Å´Â§âÊèõ
        binary_counts = self._convert_decimal_to_binary_counts(counts)
        
        total = sum(binary_counts.values())
        if total == 0:
            return 0.0

        # „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±Ë°®Á§∫ÔºàÂàùÂõû„ÅÆ„ÅøÔºâ
        if not hasattr(self, '_counts_debug_shown'):
            print(f"üîç Raw decimal counts: {dict(counts)}")
            print(f"üîç Converted binary counts: {dict(binary_counts)}")
            self._counts_debug_shown = True

        # Ê®ôÊ∫ñÁöÑ„Å™P(1)Á¢∫ÁéáË®àÁÆó
        n_1 = binary_counts.get("1", 0)
        p1 = n_1 / total
        return p1
        
    def _convert_decimal_to_binary_counts(self, decimal_counts: Dict[str, int]) -> Dict[str, int]:
        """
        OQTOPUS„ÅÆ10ÈÄ≤Êï∞counts„Çí2ÈÄ≤Êï∞ÂΩ¢Âºè„Å´Â§âÊèõ
        
        1ÈáèÂ≠ê„Éì„ÉÉ„Éà„ÅÆÂ†¥Âêà:
        0 -> "0"  (|0‚ü©Áä∂ÊÖã)
        1 -> "1"  (|1‚ü©Áä∂ÊÖã)
        """
        binary_counts = {}
        
        for decimal_key, count in decimal_counts.items():
            # „Ç≠„Éº„ÅåÊï∞ÂÄ§„ÅÆÂ†¥Âêà„Å®ÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà„Å´ÂØæÂøú
            if isinstance(decimal_key, str):
                try:
                    decimal_value = int(decimal_key)
                except ValueError:
                    # „Åô„Åß„Å´„Éê„Ç§„Éä„É™ÂΩ¢Âºè„ÅÆÂ†¥Âêà
                    binary_counts[decimal_key] = count
                    continue
            else:
                decimal_value = int(decimal_key)
            
            # 1ÈáèÂ≠ê„Éì„ÉÉ„Éà„ÅÆÂ†¥Âêà„ÅÆÂ§âÊèõ
            if decimal_value == 0:
                binary_key = "0"
            elif decimal_value == 1:
                binary_key = "1"
            else:
                # ‰∫àÊúü„Åó„Å™„ÅÑÂÄ§„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó„Åó„Å¶Ë≠¶Âëä
                print(f"‚ö†Ô∏è Unexpected count key: {decimal_key} (decimal value: {decimal_value})")
                continue
            
            # Êó¢Â≠ò„ÅÆ„Ç≠„Éº„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂä†ÁÆó
            if binary_key in binary_counts:
                binary_counts[binary_key] += count
            else:
                binary_counts[binary_key] = count
        
        return binary_counts

    def _estimate_ramsey_params_with_quality(self, p1_values: List[float], delay_times: np.ndarray) -> tuple[float, float, Dict[str, Any]]:
        """
        Ramsey„Éë„É©„É°„Éº„ÇøÊé®ÂÆöÔºàT2*„Å®„Éá„ÉÅ„É•„Éº„Éã„É≥„Ç∞Ôºâ
        """
        # NaN„ÇíÈô§Âéª
        valid_data = [(delay, p1) for delay, p1 in zip(delay_times, p1_values)
                      if not np.isnan(p1)]

        if len(valid_data) < 5:
            return 0.0, 0.0, {'method': 'insufficient_data', 'r_squared': 0.0, 'error': 'inf'}

        delays = np.array([d[0] for d in valid_data])
        p1s = np.array([d[1] for d in valid_data])

        # detuning„Å´Âøú„Åò„Å¶„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„É¢„Éá„É´„ÇíÈÅ∏Êäû
        expected_detuning = self.experiment_params.get("detuning", 0.0)
        
        try:
            from scipy.optimize import curve_fit
            
            # detuning=0„ÅÆÂ†¥ÂêàÔºöÁ¥îÁ≤ã„Å™T2*Ê∏õË°∞ÔºàÊåØÂãï„Å™„ÅóÔºâ
            if abs(expected_detuning) < 0.001:  # detuning ‚âà 0
                def t2_star_decay(t, A, T2_star, offset):
                    return A * np.exp(-t / T2_star) + offset
                
                # ÂàùÊúüÊé®ÂÆöÂÄ§
                p0 = [0.5, self.expected_t2_star, 0.5]  # A, T2*, offset
                
                # „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ÂÆüË°å
                popt, pcov = curve_fit(t2_star_decay, delays, p1s, p0=p0, 
                                     bounds=([0, 10, 0], [1.0, 100000, 1.0]),
                                     maxfev=2000)
                
                t2_star_fitted = popt[1]
                detuning_fitted = 0.0  # detuning=0„Å®„Åó„Å¶Âõ∫ÂÆö
                
                # ‰∫àÊ∏¨ÂÄ§Ë®àÁÆó„Å®R¬≤ÁÆóÂá∫
                p1_pred = t2_star_decay(delays, *popt)
                ss_res = np.sum((p1s - p1_pred) ** 2)
                ss_tot = np.sum((p1s - np.mean(p1s)) ** 2)
                r_squared = 1 - (ss_res / ss_tot) if ss_tot > 0 else 0.0
                
                # Ê®ôÊ∫ñË™§Â∑ÆË®àÁÆó
                param_error = 'inf'
                if pcov is not None and np.all(np.isfinite(pcov)):
                    param_errors = np.sqrt(np.diag(pcov))
                    t2_error = param_errors[1]
                    param_error = f"{t2_error:.1f}"
                    
                    # È´òÂìÅË≥™„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„ÅÆÊù°‰ª∂
                    if t2_error / t2_star_fitted < 0.5 and r_squared > 0.5:
                        return float(t2_star_fitted), float(detuning_fitted), {
                            'method': 'exponential_decay_t2star',
                            'r_squared': r_squared,
                            'error': param_error,
                            'quality': 'high' if r_squared > 0.8 else 'medium'
                        }
            
            else:  # detuning‚â†0„ÅÆÂ†¥ÂêàÔºöÊåØÂãï„Åô„ÇãÊ∏õË°∞
                def ramsey_oscillation(t, A, T2_star, freq, phase, offset):
                    return A * np.exp(-t / T2_star) * np.cos(2 * np.pi * freq * t * 1e-3 + phase) + offset
                
                # ÂàùÊúüÊé®ÂÆöÂÄ§
                p0 = [0.5, self.expected_t2_star, expected_detuning, 0.0, 0.5]  # A, T2*, freq, phase, offset
                
                # „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ÂÆüË°å
                popt, pcov = curve_fit(ramsey_oscillation, delays, p1s, p0=p0, 
                                     bounds=([0, 10, -10, -np.pi, 0], [1.0, 100000, 10, np.pi, 1.0]),
                                     maxfev=2000)
                
                t2_star_fitted = popt[1]
                detuning_fitted = popt[2]
                
                # ‰∫àÊ∏¨ÂÄ§Ë®àÁÆó„Å®R¬≤ÁÆóÂá∫
                p1_pred = ramsey_oscillation(delays, *popt)
                ss_res = np.sum((p1s - p1_pred) ** 2)
                ss_tot = np.sum((p1s - np.mean(p1s)) ** 2)
                r_squared = 1 - (ss_res / ss_tot) if ss_tot > 0 else 0.0
                
                # Ê®ôÊ∫ñË™§Â∑ÆË®àÁÆó
                param_error = 'inf'
                if pcov is not None and np.all(np.isfinite(pcov)):
                    param_errors = np.sqrt(np.diag(pcov))
                    t2_error = param_errors[1]
                    param_error = f"{t2_error:.1f}"
                    
                    # È´òÂìÅË≥™„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„ÅÆÊù°‰ª∂
                    if t2_error / t2_star_fitted < 0.5 and r_squared > 0.5:
                        return float(t2_star_fitted), float(detuning_fitted), {
                            'method': 'ramsey_oscillation',
                            'r_squared': r_squared,
                            'error': param_error,
                            'quality': 'high' if r_squared > 0.8 else 'medium'
                        }
            
        except (ImportError, RuntimeError, ValueError, TypeError, Exception) as e:
            print(f"Ramsey fitting failed: {str(e)[:50]}... using default values")
            pass

        # ÂÖ®„Å¶„ÅÆÊâãÊ≥ï„ÅåÂ§±Êïó„Åó„ÅüÂ†¥Âêà - „Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíËøî„Åô
        return float(self.expected_t2_star), 0.0, {
            'method': 'default_ramsey',
            'r_squared': 0.0,
            'error': 'N/A',
            'quality': 'poor'
        }

    def save_experiment_data(self, results: Dict[str, Any], 
                           metadata: Dict[str, Any] = None) -> str:
        """
        RamseyÂÆüÈ®ì„Éá„Éº„Çø‰øùÂ≠ò
        """
        ramsey_data = {
            'experiment_type': 'Ramsey_Oscillation',
            'experiment_timestamp': time.time(),
            'experiment_parameters': self.experiment_params,
            'analysis_results': results,
            'oqtopus_configuration': {
                'transpiler_options': self.transpiler_options,
                'mitigation_options': self.mitigation_options,
                'basis_gates': self.anemone_basis_gates
            },
            'metadata': metadata or {}
        }

        # „É°„Ç§„É≥ÁµêÊûú‰øùÂ≠ò
        main_file = self.data_manager.save_data(ramsey_data, "ramsey_experiment_results")

        # ËøΩÂä†„Éï„Ç°„Ç§„É´‰øùÂ≠ò
        if 'device_results' in results:
            # „Éá„Éê„Ç§„ÇπÂà•„Çµ„Éû„É™„Éº
            device_summary = {
                device: {
                    't2_star_fitted': analysis.get('t2_star_fitted', 0.0),
                    'detuning_fitted': analysis.get('detuning_fitted', 0.0),
                    'statistics': analysis['statistics']
                }
                for device, analysis in results['device_results'].items()
            }
            self.data_manager.save_data(device_summary, "device_ramsey_summary")

            # P(1)„Éá„Éº„ÇøÔºà„Éó„É≠„ÉÉ„ÉàÁî®Ôºâ
            p1_data = {
                'delay_times': self.experiment_params['delay_times'],
                'device_p1_values': {
                    device: analysis['p1_values']
                    for device, analysis in results['device_results'].items()
                }
            }
            self.data_manager.save_data(p1_data, "ramsey_p1_values_for_plotting")

        return main_file

    def generate_ramsey_plot(self, results: Dict[str, Any], save_plot: bool = True,
                           show_plot: bool = False) -> Optional[str]:
        """Generate Ramsey experiment plot"""
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            print("matplotlib not available - skipping plot generation")
            return None

        delay_times = results.get('delay_times', np.linspace(50, 50000, 51))
        device_results = results.get('device_results', {})

        if not device_results:
            print("No device results for plotting")
            return None

        # Create plot
        fig, ax = plt.subplots(figsize=(12, 8))

        # Plot experimental data for each device
        colors = ["blue", "red", "green", "orange", "purple"]

        for i, (device, device_data) in enumerate(device_results.items()):
            if "p1_values" in device_data:
                p1_values = device_data["p1_values"]
                t2_star_fitted = device_data.get("t2_star_fitted", 0.0)
                detuning_fitted = device_data.get("detuning_fitted", 0.0)
                fitting_quality = device_data.get("fitting_quality", {})
                r_squared = fitting_quality.get("r_squared", 0.0)
                color = colors[i % len(colors)]
                
                # ÂÆüÊ∏¨„Éá„Éº„Çø„Éó„É≠„ÉÉ„Éà
                ax.semilogx(
                    delay_times,
                    p1_values,
                    "o",
                    markersize=4,
                    label=f"{device} data",
                    alpha=0.8,
                    color=color,
                )
                
                # „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„ÅåÊúâÂäπ„Å™Â†¥Âêà„ÅÆ„Åø„Éï„Ç£„ÉÉ„ÉàÊõ≤Á∑ö„Çí„Éó„É≠„ÉÉ„Éà
                if self.enable_fitting and t2_star_fitted > 0:
                    fit_delays = np.logspace(np.log10(min(delay_times)), np.log10(max(delay_times)), 200)
                    A = 0.5  # ÊåØÂπÖ„ÅÆÊé®ÂÆöÂÄ§
                    offset = 0.5
                    
                    # „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„Åß‰ΩøÁî®„Åï„Çå„Åü„É¢„Éá„É´„Å´Âøú„Åò„Å¶Êõ≤Á∑ö„ÇíÁîüÊàê
                    fitting_method = fitting_quality.get('method', 'unknown')
                    
                    if fitting_method == 'exponential_decay_t2star' or abs(detuning_fitted) < 0.001:
                        # T2*Ê∏õË°∞„ÅÆ„ÅøÔºàÊåØÂãï„Å™„ÅóÔºâ
                        fit_curve = A * np.exp(-fit_delays / t2_star_fitted) + offset
                        label_text = f"{device} fit (T2*={t2_star_fitted:.0f}ns, R¬≤={r_squared:.3f}) [T2* decay]"
                    else:
                        # RamseyÊåØÂãï: P(t) = A * exp(-t/T2*) * cos(2œÄ*f*t) + offset
                        fit_curve = A * np.exp(-fit_delays / t2_star_fitted) * np.cos(2 * np.pi * detuning_fitted * fit_delays * 1e-3) + offset
                        label_text = f"{device} fit (T2*={t2_star_fitted:.0f}ns, f={detuning_fitted:.3f}MHz, R¬≤={r_squared:.3f})"
                        
                    ax.semilogx(
                        fit_delays,
                        fit_curve,
                        "-",
                        linewidth=2,
                        color=color,
                        alpha=0.7,
                        label=label_text
                    )

        # Formatting
        ax.set_xlabel("Delay time œÑ [ns] (log scale)", fontsize=14)
        ax.set_ylabel("P(1)", fontsize=14)
        title_suffix = " (with fitting)" if self.enable_fitting else " (raw data)"
        ax.set_title(f"QuantumLib Ramsey Oscillation Experiment{title_suffix}", fontsize=16, fontweight="bold")
        ax.grid(True, which="both", ls="--", linewidth=0.5)
        ax.legend(fontsize=12)
        ax.set_ylim(0, 1.1)

        plot_filename = None
        if save_plot:
            plt.tight_layout()
            plot_filename = f"ramsey_plot_{self.experiment_name}_{int(time.time())}.png"

            # Always save to experiment results directory
            if hasattr(self, 'data_manager') and hasattr(self.data_manager, 'session_dir'):
                plot_path = f"{self.data_manager.session_dir}/plots/{plot_filename}"
                plt.savefig(plot_path, dpi=300, bbox_inches='tight')
                print(f"Plot saved: {plot_path}")
                plot_filename = plot_path
            else:
                plt.savefig(plot_filename, dpi=300, bbox_inches='tight')
                print(f"‚ö†Ô∏è Plot saved to current directory: {plot_filename}")

        if show_plot:
            try:
                plt.show()
            except:
                pass

        plt.close()
        return plot_filename

    def save_complete_experiment_data(self, results: Dict[str, Any]) -> str:
        """Save experiment data and generate comprehensive report"""
        # Save main experiment data
        main_file = self.save_experiment_data(results['analysis'])

        # Generate and save plot
        plot_file = self.generate_ramsey_plot(results, save_plot=True, show_plot=False)

        # Create experiment summary
        summary = self._create_ramsey_experiment_summary(results)
        summary_file = self.data_manager.save_data(summary, "experiment_summary")

        print(f"üìä Complete Ramsey experiment data saved:")
        print(f"  ‚Ä¢ Main results: {main_file}")
        print(f"  ‚Ä¢ Plot: {plot_file if plot_file else 'Not generated'}")
        print(f"  ‚Ä¢ Summary: {summary_file}")

        return main_file

    def _create_ramsey_experiment_summary(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Create human-readable Ramsey experiment summary"""
        device_results = results.get('device_results', {})
        delay_times = results.get('delay_times', [])

        summary = {
            'experiment_overview': {
                'experiment_name': self.experiment_name,
                'timestamp': time.time(),
                'method': results.get('method', 'ramsey_oscillation'),
                'delay_points': len(delay_times),
                'devices_tested': list(device_results.keys())
            },
            'key_results': {},
            'ramsey_analysis': {
                'expected_t2_star': self.expected_t2_star,
                'clear_oscillation_detected': False
            }
        }

        # Analyze each device
        min_oscillation_threshold = 0.1  # Minimum oscillation amplitude

        for device, device_data in device_results.items():
            if 'p1_values' in device_data:
                p1_values = device_data['p1_values']
                valid_p1s = [p for p in p1_values if not np.isnan(p)]

                if valid_p1s and len(valid_p1s) >= 5:
                    oscillation_amplitude = max(valid_p1s) - min(valid_p1s)
                    t2_star_fitted = device_data.get('t2_star_fitted', 0.0)
                    detuning_fitted = device_data.get('detuning_fitted', 0.0)

                    summary['key_results'][device] = {
                        'oscillation_amplitude': oscillation_amplitude,
                        't2_star_fitted': t2_star_fitted,
                        'detuning_fitted': detuning_fitted,
                        'clear_oscillation': oscillation_amplitude > min_oscillation_threshold
                    }

                    if oscillation_amplitude > min_oscillation_threshold:
                        summary['ramsey_analysis']['clear_oscillation_detected'] = True

        return summary

    def display_results(self, results: Dict[str, Any], use_rich: bool = True) -> None:
        """Display Ramsey experiment results in formatted table"""
        device_results = results.get('device_results', {})

        if not device_results:
            print("No device results found")
            return

        if use_rich:
            try:
                from rich.console import Console
                from rich.table import Table

                console = Console()
                table = Table(title="Ramsey Oscillation Results", show_header=True, header_style="bold blue")
                table.add_column("Device", style="cyan")
                table.add_column("T2* Fitted [ns]", justify="right")
                table.add_column("Detuning [MHz]", justify="right")
                table.add_column("Oscillation", justify="right")
                table.add_column("Success Rate", justify="right")
                table.add_column("Clear Signal", justify="center")

                for device, device_data in device_results.items():
                    if 'p1_values' in device_data:
                        p1_values = device_data['p1_values']
                        valid_p1s = [p for p in p1_values if not np.isnan(p)]

                        if valid_p1s and len(valid_p1s) >= 2:
                            oscillation_amplitude = max(valid_p1s) - min(valid_p1s)
                            t2_star_fitted = device_data.get('t2_star_fitted', 0.0)
                            detuning_fitted = device_data.get('detuning_fitted', 0.0)
                            
                            # ÊàêÂäüÁéá„ÅÆÂèñÂæó
                            stats = device_data.get('statistics', {})
                            success_rate = stats.get('success_rate', 0.0)
                            successful_jobs = stats.get('successful_jobs', 0)
                            total_jobs = stats.get('total_jobs', 0)

                            clear_signal = "YES" if oscillation_amplitude > 0.1 else "NO"
                            signal_style = "green" if oscillation_amplitude > 0.1 else "yellow"

                            table.add_row(
                                device.upper(),
                                f"{t2_star_fitted:.1f}",
                                f"{detuning_fitted:.3f}",
                                f"{oscillation_amplitude:.3f}",
                                f"{success_rate*100:.1f}% ({successful_jobs}/{total_jobs})",
                                clear_signal,
                                style=signal_style if oscillation_amplitude > 0.1 else None
                            )

                console.print(table)
                console.print(f"\nExpected T2*: {self.expected_t2_star} ns")
                expected_detuning = self.experiment_params.get("detuning", 0.0)
                if abs(expected_detuning) < 0.001:
                    console.print(f"Detuning: {expected_detuning} MHz ‚Üí Pure T2* decay mode")
                else:
                    console.print(f"Detuning: {expected_detuning} MHz ‚Üí Ramsey oscillation mode")
                fitting_status = "enabled" if self.enable_fitting else "disabled"
                console.print(f"Parameter fitting: {fitting_status}")
                console.print(f"Clear oscillation threshold: 0.1")

            except ImportError:
                use_rich = False

        if not use_rich:
            # Fallback to simple text display
            print("\n" + "="*60)
            print("Ramsey Oscillation Results")
            print("="*60)

            for device, device_data in device_results.items():
                if 'p1_values' in device_data:
                    p1_values = device_data['p1_values']
                    valid_p1s = [p for p in p1_values if not np.isnan(p)]

                    if valid_p1s and len(valid_p1s) >= 2:
                        oscillation_amplitude = max(valid_p1s) - min(valid_p1s)
                        t2_star_fitted = device_data.get('t2_star_fitted', 0.0)
                        detuning_fitted = device_data.get('detuning_fitted', 0.0)
                        
                        # ÊàêÂäüÁéá„ÅÆÂèñÂæó
                        stats = device_data.get('statistics', {})
                        success_rate = stats.get('success_rate', 0.0)
                        successful_jobs = stats.get('successful_jobs', 0)
                        total_jobs = stats.get('total_jobs', 0)

                        clear_signal = "YES" if oscillation_amplitude > 0.1 else "NO"

                        print(f"Device: {device.upper()}")
                        print(f"  T2* Fitted: {t2_star_fitted:.1f} ns")
                        print(f"  Detuning: {detuning_fitted:.3f} MHz")
                        print(f"  Oscillation: {oscillation_amplitude:.3f}")
                        print(f"  Success Rate: {success_rate*100:.1f}% ({successful_jobs}/{total_jobs})")
                        print(f"  Clear Signal: {clear_signal}")
                        print()

            print(f"Expected T2*: {self.expected_t2_star} ns")
            expected_detuning = self.experiment_params.get("detuning", 0.0)
            if abs(expected_detuning) < 0.001:
                print(f"Detuning: {expected_detuning} MHz ‚Üí Pure T2* decay mode")
            else:
                print(f"Detuning: {expected_detuning} MHz ‚Üí Ramsey oscillation mode")
            fitting_status = "enabled" if self.enable_fitting else "disabled"
            print(f"Parameter fitting: {fitting_status}")
            print(f"Clear oscillation threshold: 0.1")
            print("="*60)